#!/bin/bash
# -*- sh -*-

: << =cut

=pod

=encoding UTF-8

=head1 NAME

cake_tin_pps_ - Plugin to monitor cake's tin' pps

=head1 CONFIGURATION

None needed.

=head1 INTERPRETATION

Cake, also known as sch_cake is a modern bandwidth limiter, which eliminates
buffer bloat over slow links. It's also capable to give flows, hosts and each 
flow of each host a fair part of the avaible bandwidth.

This plugin allows for a monitoring packets per tins on the qdisc.

=head1 SEE ALSO

Take a look at "man cake" to get more information about cake.

=head1 MAGIC MARKERS

 #%# family=auto
 #%# capabilities=autoconf suggest

=head1 AUTHORS

RubenKelevra <ruben@vfn-nrw.de>

work based on the tc plugin, authors:
Steve Schnepp <steve.schnepp@gmail.com>,
Samuel Smith <esaym@cpan.org>,
Nye Liu <nyet@nyet.org>

=head1 LICENSE

GPLv2 or later

=cut

DEVICE="${0##*/cake_tin_pps_}"

# green/blue -> red
eight_color=("006b5f" "1a9850" "66bd63" "a6d96a" "fdae61" "f46d43" "d73027" "9427d7")
four_color=("3288bd" "abdda4" "fdae61" "d53e4f")
three_color=("3288bd" "abdda4" "d53e4f")

tc_get_ifb_dev() {
	dev="$(/sbin/tc filter show dev "$DEVICE" parent ffff: protocol all | grep "mirred" | grep "Egress Redirect to device")"
	[ "$?" -eq "1" ] && return 1
	
	echo "$dev" | sed -n 's/.* device \([^ ]*\).*/\1/p' | tr ')' ' ' | awk '{ print $1 }'
}

tc_cake_get_diffserv() {
	/sbin/tc -s qdisc show dev "$1" | head -n1 | grep -i "diffserv3" > /dev/null
	if [ "$?" -eq "0" ]; then
		echo 3
	fi
	/sbin/tc -s qdisc show dev "$1" | head -n1 | grep -i "diffserv4" > /dev/null
	if [ "$?" -eq "0" ]; then
		echo 4
	fi
	/sbin/tc -s qdisc show dev "$1" | head -n1 | grep -i "diffserv8" > /dev/null
	if [ "$?" -eq "0" ]; then
		echo 8
	fi
	return 0
}

tc_cake_get_pkts() { 
	/sbin/tc -s qdisc show dev "$1" | grep "^  pkts"
}

DEVICE_IN="$(tc_get_ifb_dev)"
has_if_in=$?

diffserv_no="$(tc_cake_get_diffserv "$DEVICE")"
if [ "$has_if_in" -eq "0" ]; then
	diffserv_in_no="$(tc_cake_get_diffserv "$DEVICE_IN")"
	
	if [ ! "$diffserv_no" == "$diffserv_in_no" ]; then
		echo "cake_tin_pps_: diffserv setting different between egress and ingress device - this cannot be plotted, exiting" >&2
		exit 1
	fi
fi

case "$1" in
	autoconf)
	if [ -r /proc/net/dev ]; then
		echo yes
		exit 0
	else
		echo "no (/proc/net/dev not found)"
		exit 1
	fi
	;;
	suggest)
	if [ -r /proc/net/dev ]; then
		ifs="$(awk '
				/^ *(eth|tap|bond|wlan|ath|ra|sw|eno|ens|enp|wlp|wl)[0-9]*/ {
				   split($0, a, /: */);
				   gsub(/^ +/,"",a[1]);
				   if (($2 > 0) || ($10 > 0)) print a[1]; }' /proc/net/dev)"
		cake_ifs=()
		for if in $ifs; do
			qdisc="$(/sbin/tc -s qdisc show dev "$if" | head -n1 | awk '{ print $2 }')"
			if [ "$qdisc" == "cake" ]; then
				cake_ifs+=("$if")
			fi
		done
		echo "${cake_ifs[@]}"
	fi
	exit 0
	;;
	config)
	
	if [ "$has_if_in" -eq "0" ]; then
		echo "graph_title $DEVICE ($DEVICE_IN) cake QoS tin packet throughput"
	else
		echo "graph_title $DEVICE cake QoS tin packet throughput"
	fi
	echo 'graph_args --base 1000'
	if [ "$has_if_in" -eq "0" ]; then
		echo 'graph_vlabel pps in (-) / out (+)'
	else
		echo 'graph_vlabel packets per second'
	fi
	echo 'graph_category network'
	if [ "$has_if_in" -eq "0" ]; then
		echo "graph_info This graph shows the packages per tin of egress+ingress traffic of the $DEVICE ($DEVICE_IN) network interface."
	else
		echo "graph_info This graph shows the packages per tin of egress traffic of the $DEVICE network interface."
	fi
	
	if [ "$diffserv_no" == "3" ]; then

		if [ "$has_if_in" -eq "0" ]; then
			echo "bulk_in.label Bulk"
			echo "bulk_in.draw AREA"
			echo "bulk_in.colour ${three_color[0]}"
			echo "bulk_in.type DERIVE"
			echo "bulk_in.min 0"
			echo "bulk_in.info sent bulk packets thru cake"
			echo "bulk_in.graph no"
		fi
		echo "bulk.label Bulk"
		echo "bulk.draw AREA"
		echo "bulk.colour ${three_color[0]}"
		echo "bulk.type DERIVE"
		echo "bulk.min 0"
		echo "bulk.info sent bulk packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "bulk.negative bulk_in"
		
		if [ "$has_if_in" -eq "0" ]; then
			echo "besteffort_in.label Best Effort"
			echo "besteffort_in.draw STACK"
			echo "besteffort_in.colour ${three_color[1]}"
			echo "besteffort_in.type DERIVE"
			echo "besteffort_in.min 0"
			echo "besteffort_in.info sent best effort packets thru cake"
			echo "besteffort_in.graph no"
		fi
		echo "besteffort.label Best Effort"
		echo "besteffort.draw STACK"
		echo "besteffort.colour ${three_color[1]}"
		echo "besteffort.type DERIVE"
		echo "besteffort.min 0"
		echo "besteffort.info sent best effort packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "besteffort.negative besteffort_in"
		
		if [ "$has_if_in" -eq "0" ]; then
			echo "voice_in.label Voice"
			echo "voice_in.draw STACK"
			echo "voice_in.colour ${three_color[2]}"
			echo "voice_in.type DERIVE"
			echo "voice_in.min 0"
			echo "voice_in.info sent Voice packets thru cake"
			echo "voice_in.graph no"
		fi
		echo "voice.label Voice"
		echo "voice.draw STACK"
		echo "voice.colour ${three_color[2]}"
		echo "voice.type DERIVE"
		echo "voice.min 0"
		echo "voice.info sent Voice packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "voice.negative voice_in"
		
		exit 0
	fi
	
	if [ "$diffserv_no" == "4" ]; then
		
		if [ "$has_if_in" -eq "0" ]; then
			echo "bulk_in.label Bulk"
			echo "bulk_in.draw AREA"
			echo "bulk_in.colour ${four_color[0]}"
			echo "bulk_in.type DERIVE"
			echo "bulk_in.min 0"
			echo "bulk_in.info sent bulk packets thru cake"
			echo "bulk_in.graph no"
		fi
		echo "bulk.label Bulk"
		echo "bulk.draw AREA"
		echo "bulk.colour ${four_color[0]}"
		echo "bulk.type DERIVE"
		echo "bulk.min 0"
		echo "bulk.info sent bulk packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "bulk.negative bulk_in"
		
		if [ "$has_if_in" -eq "0" ]; then
			echo "besteffort_in.label Best Effort"
			echo "besteffort_in.draw STACK"
			echo "besteffort_in.colour ${four_color[1]}"
			echo "besteffort_in.type DERIVE"
			echo "besteffort_in.min 0"
			echo "besteffort_in.info sent best effort packets thru cake"
			echo "besteffort_in.graph no"
		fi
		echo "besteffort.label Best Effort"
		echo "besteffort.draw STACK"
		echo "besteffort.colour ${four_color[1]}"
		echo "besteffort.type DERIVE"
		echo "besteffort.min 0"
		echo "besteffort.info sent best effort packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "besteffort.negative besteffort_in"
		
		if [ "$has_if_in" -eq "0" ]; then
			echo "video_in.label Video"
			echo "video_in.draw STACK"
			echo "video_in.colour ${four_color[2]}"
			echo "video_in.type DERIVE"
			echo "video_in.min 0"
			echo "video_in.info sent Video packets thru cake"
			echo "video_in.graph no"
		fi
		echo "video.label Video"
		echo "video.draw STACK"
		echo "video.colour ${four_color[2]}"
		echo "video.type DERIVE"
		echo "video.min 0"
		echo "video.info sent Video packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "video.negative video_in"
		
		if [ "$has_if_in" -eq "0" ]; then
			echo "voice_in.label Voice"
			echo "voice_in.draw STACK"
			echo "voice_in.colour ${four_color[3]}"
			echo "voice_in.type DERIVE"
			echo "voice_in.min 0"
			echo "voice_in.info sent Voice packets thru cake"
			echo "voice_in.graph no"
		fi
		echo "voice.label Voice"
		echo "voice.draw STACK"
		echo "voice.colour ${four_color[3]}"
		echo "voice.type DERIVE"
		echo "voice.min 0"
		echo "voice.info sent Voice packets thru cake"
		[ "$has_if_in" -eq "0" ] && echo "voice.negative voice_in"
		
		exit 0
	fi
	
	if [ "$diffserv_no" == "8" ]; then
		if [ "$has_if_in" -eq "0" ]; then		
			echo "tin1_in.label Tin 1"
			echo "tin1_in.draw AREA"
			echo "tin1.colour ${eight_color[0]}"
			echo "tin1_in.type DERIVE"
			echo "tin1_in.min 0"
			echo "tin1_in.info sent Tin $i packets with ecn marks thru cake"
			echo "tin1_in.graph no"
		fi
		echo "tin1.label Tin 1"
		echo "tin1.draw AREA"
		echo "tin1.colour ${eight_color[0]}"
		echo "tin1.type DERIVE"
		echo "tin1.min 0"
		echo "tin1.info sent Tin $i packets with ecn marks thru cake"
		[ "$has_if_in" -eq "0" ] && echo "tin1.negative tin1_in"
		
		for i in `seq 2 8`; do
			if [ "$has_if_in" -eq "0" ]; then				
				echo "tin${i}_in.label Tin $i"
				echo "tin${i}_in.draw STACK"
				echo "tin${i}_in.colour ${eight_color[$((i - 1))]}"
				echo "tin${i}_in.type DERIVE"
				echo "tin${i}_in.min 0"
				echo "tin${i}_in.info Tin $i packets with ecn marks thru cake"
				echo "tin${i}_in.graph no"
			fi
			echo "tin${i}.label Tin $i"
			echo "tin${i}.draw STACK"
			echo "tin${i}.colour ${eight_color[$((i - 1))]}"
			echo "tin${i}.type DERIVE"
			echo "tin${i}.min 0"
			echo "tin${i}.info Tin $i packets with ecn marks thru cake"
			[ "$has_if_in" -eq "0" ] && echo "tin${i}.negative tin${i}_in"
		done
		
		exit 0  
	fi
	;;
esac

if [ "$diffserv_no" == "3" ]; then
	tc_cake_get_pkts "$DEVICE" | awk '{
	print "bulk.value " $2
	print "besteffort.value " $3
	print "voice.value " $4
	}'
	if [ "$has_if_in" -eq "0" ]; then
		tc_cake_get_pkts "$DEVICE_IN" | awk '{
		print "bulk_in.value " $2
		print "besteffort_in.value " $3
		print "voice_in.value " $4
		}'
	fi
	exit 0
fi
if [ "$diffserv_no" == "4" ]; then
	tc_cake_get_pkts "$DEVICE" | awk '{
	print "bulk.value " $2
	print "besteffort.value " $3
	print "video.value " $4
	print "voice.value " $5
	}'
	if [ "$has_if_in" -eq "0" ]; then
		tc_cake_get_pkts "$DEVICE_IN" | awk '{
		print "bulk_in.value " $2
		print "besteffort_in.value " $3
		print "video_in.value " $4
		print "voice_in.value " $5
		}'
	fi
	exit 0
fi
if [ "$diffserv_no" == "8" ]; then
	tc_cake_get_pkts "$DEVICE" | awk '{
	print "tin1.value " $2
	print "tin2.value " $3
	print "tin3.value " $4
	print "tin4.value " $5
	print "tin5.value " $6
	print "tin6.value " $7
	print "tin7.value " $8
	print "tin8.value " $9
	}'
	if [ "$has_if_in" -eq "0" ]; then
		tc_cake_get_pkts "$DEVICE_IN" | awk '{
		print "tin1_in.value " $2
		print "tin2_in.value " $3
		print "tin3_in.value " $4
		print "tin4_in.value " $5
		print "tin5_in.value " $6
		print "tin6_in.value " $7
		print "tin7_in.value " $8
		print "tin8_in.value " $9
		}'
	fi
	exit 0
fi


echo "cake_tin_pps_: no diffserv or unknown parameter set (best effort?)" >&2
exit 1
